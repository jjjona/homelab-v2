---
# 05b-arr-config.yml
# Configures all arr suite apps, Jellyfin, Jellyseerr, and Autobrr via their APIs.
# Prerequisites: 03-core-services.yml must have been run (all containers up, API keys pre-seeded).
#
# What this playbook does:
#   - Sonarr:     root folder, download client, remote path mapping
#   - Radarr:     root folder, download client, remote path mapping
#   - Prowlarr:   connects to Sonarr, Radarr, Lidarr as applications
#   - Lidarr:     root folder, download client, remote path mapping
#   - Jellyfin:   initial setup wizard, media libraries, VAAPI transcoding
#   - Jellyseerr: initial setup (connect to Jellyfin + Sonarr + Radarr)
#   - Bazarr:     connect to Sonarr + Radarr, set English subtitles
#   - Autobrr:    create account, add download client
#
# What stays manual:
#   - Jellyfin transcoding fine-tuning
#   - Jellyseerr user management
#   - Bazarr: add subtitle providers (OpenSubtitles account needed)
# See also: 05d-trackers.yml for Prowlarr indexers + Autobrr IRC/filters

- name: Configure arr suite and media services
  hosts: docker_host
  gather_facts: false

  vars:
    secrets: "{{ lookup('community.sops.sops', playbook_dir + '/../../docker/secrets.sops.yml') | from_yaml }}"
    seedbox: "{{ lookup('community.sops.sops', playbook_dir + '/../secrets/seedbox.sops.yml') | from_yaml }}"

    # Localhost API endpoints (via port bindings)
    sonarr_url: "http://127.0.0.1:8989"
    radarr_url: "http://127.0.0.1:7878"
    prowlarr_url: "http://127.0.0.1:9696"
    lidarr_url: "http://127.0.0.1:8686"
    jellyfin_url: "http://127.0.0.1:8096"
    jellyseerr_url: "http://127.0.0.1:5055"
    autobrr_url: "http://127.0.0.1:7474"
    bazarr_url: "http://127.0.0.1:6767"

    # Seedbox qBittorrent config
    seedbox_qbit_host: "{{ seedbox.seedbox_host }}"
    seedbox_qbit_port: 13291
    seedbox_qbit_user: "{{ seedbox.seedbox_user }}"
    seedbox_qbit_password: "{{ seedbox.seedbox_qbit_password }}"
    seedbox_download_path: "{{ seedbox.seedbox_remote_path }}"

    # Custom format for preferring dual audio / English dub releases
    dual_audio_custom_format:
      name: Dual Audio
      includeCustomFormatWhenRenaming: false
      specifications:
        - name: Dual Audio
          implementation: ReleaseTitleSpecification
          negate: false
          required: false
          fields:
            - name: value
              value: "\\bdual[.\\s_-]?audio\\b"
        - name: English Dub
          implementation: ReleaseTitleSpecification
          negate: false
          required: false
          fields:
            - name: value
              value: "\\benglish[.\\s_-]?dub(bed)?\\b"
        - name: Multi Audio
          implementation: ReleaseTitleSpecification
          negate: false
          required: false
          fields:
            - name: value
              value: "\\bmulti[.\\s_-]?(audio|lang)\\b"

  pre_tasks:
    - name: Wait for SSH connection
      ansible.builtin.wait_for_connection:
        timeout: 60

  tasks:

    # ================================================================
    # SONARR — root folder, download client, remote path mapping
    # ================================================================

    - name: Sonarr — check root folders
      ansible.builtin.uri:
        url: "{{ sonarr_url }}/api/v3/rootfolder"
        headers:
          X-Api-Key: "{{ secrets.sonarr_api_key }}"
      register: sonarr_root_folders

    - name: Sonarr — add root folder
      ansible.builtin.uri:
        url: "{{ sonarr_url }}/api/v3/rootfolder"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.sonarr_api_key }}"
        body_format: json
        body:
          path: /media/tv
        status_code: [200, 201]
      when: sonarr_root_folders.json | selectattr('path', 'equalto', '/media/tv') | list | length == 0

    - name: Sonarr — check download clients
      ansible.builtin.uri:
        url: "{{ sonarr_url }}/api/v3/downloadclient"
        headers:
          X-Api-Key: "{{ secrets.sonarr_api_key }}"
      register: sonarr_download_clients

    - name: Sonarr — add qBittorrent download client
      ansible.builtin.uri:
        url: "{{ sonarr_url }}/api/v3/downloadclient"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.sonarr_api_key }}"
        body_format: json
        body:
          name: Seedbox
          implementation: QBittorrent
          configContract: QBittorrentSettings
          protocol: torrent
          enable: true
          priority: 1
          removeCompletedDownloads: false
          removeFailedDownloads: true
          fields:
            - name: host
              value: "{{ seedbox_qbit_host }}"
            - name: port
              value: "{{ seedbox_qbit_port }}"
            - name: username
              value: "{{ seedbox_qbit_user }}"
            - name: password
              value: "{{ seedbox_qbit_password }}"
            - name: tvCategory
              value: tv
            - name: useSsl
              value: false
        status_code: [200, 201]
      when: sonarr_download_clients.json | selectattr('name', 'equalto', 'Seedbox') | list | length == 0
      no_log: true

    - name: Sonarr — check remote path mappings
      ansible.builtin.uri:
        url: "{{ sonarr_url }}/api/v3/remotepathmapping"
        headers:
          X-Api-Key: "{{ secrets.sonarr_api_key }}"
      register: sonarr_remote_paths

    - name: Sonarr — add remote path mapping
      ansible.builtin.uri:
        url: "{{ sonarr_url }}/api/v3/remotepathmapping"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.sonarr_api_key }}"
        body_format: json
        body:
          host: "{{ seedbox_qbit_host }}"
          remotePath: "{{ seedbox_download_path }}/"
          localPath: /media/downloads/complete/
        status_code: [200, 201]
      when: sonarr_remote_paths.json | selectattr('host', 'equalto', seedbox_qbit_host) | list | length == 0

    - name: Sonarr — check custom formats
      ansible.builtin.uri:
        url: "{{ sonarr_url }}/api/v3/customformat"
        headers:
          X-Api-Key: "{{ secrets.sonarr_api_key }}"
      register: sonarr_custom_formats

    - name: Sonarr — create Dual Audio custom format
      ansible.builtin.uri:
        url: "{{ sonarr_url }}/api/v3/customformat"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.sonarr_api_key }}"
        body_format: json
        body: "{{ dual_audio_custom_format }}"
        status_code: [200, 201]
      register: sonarr_dual_audio_cf
      when: sonarr_custom_formats.json | selectattr('name', 'equalto', 'Dual Audio') | list | length == 0

    - name: Sonarr — get Dual Audio format ID
      ansible.builtin.set_fact:
        sonarr_dual_audio_id: >-
          {{ sonarr_dual_audio_cf.json.id | default(
             (sonarr_custom_formats.json | selectattr('name', 'equalto', 'Dual Audio') | first).id
          ) }}

    - name: Sonarr — get quality profile HD 720p/1080p
      ansible.builtin.uri:
        url: "{{ sonarr_url }}/api/v3/qualityprofile/6"
        headers:
          X-Api-Key: "{{ secrets.sonarr_api_key }}"
      register: sonarr_profile_6

    - name: Sonarr — add Dual Audio score to quality profile
      ansible.builtin.uri:
        url: "{{ sonarr_url }}/api/v3/qualityprofile/6"
        method: PUT
        headers:
          X-Api-Key: "{{ secrets.sonarr_api_key }}"
        body_format: json
        body: >-
          {{ sonarr_profile_6.json | combine({
            'upgradeAllowed': true,
            'minFormatScore': 0,
            'cutoffFormatScore': 150,
            'formatItems': [{'format': sonarr_dual_audio_id | int, 'name': 'Dual Audio', 'score': 150}]
          }) }}
        status_code: [200, 202]
      when: >-
        not sonarr_profile_6.json.upgradeAllowed or
        sonarr_profile_6.json.cutoffFormatScore != 150 or
        sonarr_profile_6.json.formatItems | selectattr('name', 'equalto', 'Dual Audio') | selectattr('score', 'equalto', 150) | list | length == 0

    # ================================================================
    # RADARR — root folder, download client, remote path mapping
    # ================================================================

    - name: Radarr — check root folders
      ansible.builtin.uri:
        url: "{{ radarr_url }}/api/v3/rootfolder"
        headers:
          X-Api-Key: "{{ secrets.radarr_api_key }}"
      register: radarr_root_folders

    - name: Radarr — add root folder
      ansible.builtin.uri:
        url: "{{ radarr_url }}/api/v3/rootfolder"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.radarr_api_key }}"
        body_format: json
        body:
          path: /media/movies
        status_code: [200, 201]
      when: radarr_root_folders.json | selectattr('path', 'equalto', '/media/movies') | list | length == 0

    - name: Radarr — check download clients
      ansible.builtin.uri:
        url: "{{ radarr_url }}/api/v3/downloadclient"
        headers:
          X-Api-Key: "{{ secrets.radarr_api_key }}"
      register: radarr_download_clients

    - name: Radarr — add qBittorrent download client
      ansible.builtin.uri:
        url: "{{ radarr_url }}/api/v3/downloadclient"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.radarr_api_key }}"
        body_format: json
        body:
          name: Seedbox
          implementation: QBittorrent
          configContract: QBittorrentSettings
          protocol: torrent
          enable: true
          priority: 1
          removeCompletedDownloads: false
          removeFailedDownloads: true
          fields:
            - name: host
              value: "{{ seedbox_qbit_host }}"
            - name: port
              value: "{{ seedbox_qbit_port }}"
            - name: username
              value: "{{ seedbox_qbit_user }}"
            - name: password
              value: "{{ seedbox_qbit_password }}"
            - name: movieCategory
              value: movies
            - name: useSsl
              value: false
        status_code: [200, 201]
      when: radarr_download_clients.json | selectattr('name', 'equalto', 'Seedbox') | list | length == 0
      no_log: true

    - name: Radarr — check remote path mappings
      ansible.builtin.uri:
        url: "{{ radarr_url }}/api/v3/remotepathmapping"
        headers:
          X-Api-Key: "{{ secrets.radarr_api_key }}"
      register: radarr_remote_paths

    - name: Radarr — add remote path mapping
      ansible.builtin.uri:
        url: "{{ radarr_url }}/api/v3/remotepathmapping"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.radarr_api_key }}"
        body_format: json
        body:
          host: "{{ seedbox_qbit_host }}"
          remotePath: "{{ seedbox_download_path }}/"
          localPath: /media/downloads/complete/
        status_code: [200, 201]
      when: radarr_remote_paths.json | selectattr('host', 'equalto', seedbox_qbit_host) | list | length == 0

    - name: Radarr — get quality definitions
      ansible.builtin.uri:
        url: "{{ radarr_url }}/api/v3/qualitydefinition"
        headers:
          X-Api-Key: "{{ secrets.radarr_api_key }}"
      register: radarr_quality_defs

    - name: Radarr — cap 1080p/720p quality sizes (~10GB for 2hr movie)
      ansible.builtin.uri:
        url: "{{ radarr_url }}/api/v3/qualitydefinition/{{ item.id }}"
        method: PUT
        headers:
          X-Api-Key: "{{ secrets.radarr_api_key }}"
        body_format: json
        body: "{{ item | combine({'maxSize': 85.0, 'preferredSize': 70.0}) }}"
        status_code: [200, 202]
      loop: "{{ radarr_quality_defs.json }}"
      loop_control:
        label: "{{ item.quality.name }}"
      when: >-
        ('1080' in item.quality.name or '720' in item.quality.name) and
        (item.maxSize is not defined or item.maxSize is none or item.maxSize == 0 or item.maxSize > 85)

    - name: Radarr — check custom formats
      ansible.builtin.uri:
        url: "{{ radarr_url }}/api/v3/customformat"
        headers:
          X-Api-Key: "{{ secrets.radarr_api_key }}"
      register: radarr_custom_formats

    - name: Radarr — create Dual Audio custom format
      ansible.builtin.uri:
        url: "{{ radarr_url }}/api/v3/customformat"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.radarr_api_key }}"
        body_format: json
        body: "{{ dual_audio_custom_format }}"
        status_code: [200, 201]
      register: radarr_dual_audio_cf
      when: radarr_custom_formats.json | selectattr('name', 'equalto', 'Dual Audio') | list | length == 0

    - name: Radarr — get Dual Audio format ID
      ansible.builtin.set_fact:
        radarr_dual_audio_id: >-
          {{ radarr_dual_audio_cf.json.id | default(
             (radarr_custom_formats.json | selectattr('name', 'equalto', 'Dual Audio') | first).id
          ) }}

    - name: Radarr — get quality profile HD 720p/1080p
      ansible.builtin.uri:
        url: "{{ radarr_url }}/api/v3/qualityprofile/6"
        headers:
          X-Api-Key: "{{ secrets.radarr_api_key }}"
      register: radarr_profile_6

    - name: Radarr — add Dual Audio score to quality profile
      ansible.builtin.uri:
        url: "{{ radarr_url }}/api/v3/qualityprofile/6"
        method: PUT
        headers:
          X-Api-Key: "{{ secrets.radarr_api_key }}"
        body_format: json
        body: >-
          {{ radarr_profile_6.json | combine({
            'upgradeAllowed': true,
            'minFormatScore': 0,
            'cutoffFormatScore': 150,
            'formatItems': [{'format': radarr_dual_audio_id | int, 'name': 'Dual Audio', 'score': 150}]
          }) }}
        status_code: [200, 202]
      when: >-
        not radarr_profile_6.json.upgradeAllowed or
        radarr_profile_6.json.cutoffFormatScore != 150 or
        radarr_profile_6.json.formatItems | selectattr('name', 'equalto', 'Dual Audio') | selectattr('score', 'equalto', 150) | list | length == 0

    # ================================================================
    # PROWLARR — connect to Sonarr, Radarr, Lidarr
    # ================================================================

    - name: Prowlarr — check existing applications
      ansible.builtin.uri:
        url: "{{ prowlarr_url }}/api/v1/applications"
        headers:
          X-Api-Key: "{{ secrets.prowlarr_api_key }}"
      register: prowlarr_apps

    - name: Prowlarr — remove apps with old prowlarrUrl (pre-VPN)
      ansible.builtin.uri:
        url: "{{ prowlarr_url }}/api/v1/applications/{{ item.id }}"
        method: DELETE
        headers:
          X-Api-Key: "{{ secrets.prowlarr_api_key }}"
        status_code: [200, 204]
      loop: "{{ prowlarr_apps.json | selectattr('fields', 'defined') | list }}"
      loop_control:
        label: "{{ item.name }}"
      when: >-
        item.fields | selectattr('name', 'equalto', 'prowlarrUrl')
        | selectattr('value', 'equalto', 'http://prowlarr:9696')
        | list | length > 0

    - name: Prowlarr — refresh applications list after cleanup
      ansible.builtin.uri:
        url: "{{ prowlarr_url }}/api/v1/applications"
        headers:
          X-Api-Key: "{{ secrets.prowlarr_api_key }}"
      register: prowlarr_apps

    - name: Prowlarr — add Sonarr application
      ansible.builtin.uri:
        url: "{{ prowlarr_url }}/api/v1/applications"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.prowlarr_api_key }}"
        body_format: json
        body:
          name: Sonarr
          implementation: Sonarr
          configContract: SonarrSettings
          syncLevel: fullSync
          tags: []
          fields:
            - name: prowlarrUrl
              value: "http://gluetun:9696"
            - name: baseUrl
              value: "http://sonarr:8989"
            - name: apiKey
              value: "{{ secrets.sonarr_api_key }}"
            - name: syncCategories
              value:
                - 5000
                - 5010
                - 5020
                - 5030
                - 5040
                - 5045
                - 5050
                - 5060
                - 5070
                - 5080
            - name: syncRejectBlocklistedTorrentHashesWhileGrabbing
              value: false
        status_code: [200, 201]
      when: prowlarr_apps.json | selectattr('name', 'equalto', 'Sonarr') | list | length == 0
      no_log: true

    - name: Prowlarr — add Radarr application
      ansible.builtin.uri:
        url: "{{ prowlarr_url }}/api/v1/applications"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.prowlarr_api_key }}"
        body_format: json
        body:
          name: Radarr
          implementation: Radarr
          configContract: RadarrSettings
          syncLevel: fullSync
          tags: []
          fields:
            - name: prowlarrUrl
              value: "http://gluetun:9696"
            - name: baseUrl
              value: "http://radarr:7878"
            - name: apiKey
              value: "{{ secrets.radarr_api_key }}"
            - name: syncCategories
              value:
                - 2000
                - 2010
                - 2020
                - 2030
                - 2040
                - 2045
                - 2050
                - 2060
                - 2070
                - 2080
            - name: syncRejectBlocklistedTorrentHashesWhileGrabbing
              value: false
        status_code: [200, 201]
      when: prowlarr_apps.json | selectattr('name', 'equalto', 'Radarr') | list | length == 0
      no_log: true

    - name: Prowlarr — add Lidarr application
      ansible.builtin.uri:
        url: "{{ prowlarr_url }}/api/v1/applications"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.prowlarr_api_key }}"
        body_format: json
        body:
          name: Lidarr
          implementation: Lidarr
          configContract: LidarrSettings
          syncLevel: fullSync
          tags: []
          fields:
            - name: prowlarrUrl
              value: "http://gluetun:9696"
            - name: baseUrl
              value: "http://lidarr:8686"
            - name: apiKey
              value: "{{ secrets.lidarr_api_key }}"
            - name: syncCategories
              value:
                - 3000
                - 3010
                - 3020
                - 3030
                - 3040
            - name: syncRejectBlocklistedTorrentHashesWhileGrabbing
              value: false
        status_code: [200, 201]
      when: prowlarr_apps.json | selectattr('name', 'equalto', 'Lidarr') | list | length == 0
      no_log: true

    # ================================================================
    # LIDARR — root folder, download client, remote path mapping
    # ================================================================

    - name: Lidarr — check root folders
      ansible.builtin.uri:
        url: "{{ lidarr_url }}/api/v1/rootfolder"
        headers:
          X-Api-Key: "{{ secrets.lidarr_api_key }}"
      register: lidarr_root_folders

    - name: Lidarr — add root folder
      ansible.builtin.uri:
        url: "{{ lidarr_url }}/api/v1/rootfolder"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.lidarr_api_key }}"
        body_format: json
        body:
          name: Music
          path: /media/music
          defaultMetadataProfileId: 1
          defaultQualityProfileId: 1
          defaultMonitorOption: all
        status_code: [200, 201]
      when: lidarr_root_folders.json | selectattr('path', 'equalto', '/media/music') | list | length == 0

    - name: Lidarr — check download clients
      ansible.builtin.uri:
        url: "{{ lidarr_url }}/api/v1/downloadclient"
        headers:
          X-Api-Key: "{{ secrets.lidarr_api_key }}"
      register: lidarr_download_clients

    - name: Lidarr — add qBittorrent download client
      ansible.builtin.uri:
        url: "{{ lidarr_url }}/api/v1/downloadclient"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.lidarr_api_key }}"
        body_format: json
        body:
          name: Seedbox
          implementation: QBittorrent
          configContract: QBittorrentSettings
          protocol: torrent
          enable: true
          priority: 1
          removeCompletedDownloads: false
          removeFailedDownloads: true
          fields:
            - name: host
              value: "{{ seedbox_qbit_host }}"
            - name: port
              value: "{{ seedbox_qbit_port }}"
            - name: username
              value: "{{ seedbox_qbit_user }}"
            - name: password
              value: "{{ seedbox_qbit_password }}"
            - name: musicCategory
              value: music
            - name: useSsl
              value: false
        status_code: [200, 201]
      when: lidarr_download_clients.json | selectattr('name', 'equalto', 'Seedbox') | list | length == 0
      no_log: true

    - name: Lidarr — check remote path mappings
      ansible.builtin.uri:
        url: "{{ lidarr_url }}/api/v1/remotepathmapping"
        headers:
          X-Api-Key: "{{ secrets.lidarr_api_key }}"
      register: lidarr_remote_paths

    - name: Lidarr — add remote path mapping
      ansible.builtin.uri:
        url: "{{ lidarr_url }}/api/v1/remotepathmapping"
        method: POST
        headers:
          X-Api-Key: "{{ secrets.lidarr_api_key }}"
        body_format: json
        body:
          host: "{{ seedbox_qbit_host }}"
          remotePath: "{{ seedbox_download_path }}/"
          localPath: /media/downloads/complete/
        status_code: [200, 201]
      when: lidarr_remote_paths.json | selectattr('host', 'equalto', seedbox_qbit_host) | list | length == 0

    # ================================================================
    # JELLYFIN — initial setup wizard
    # ================================================================

    - name: Jellyfin — try to authenticate (check if wizard already completed)
      ansible.builtin.uri:
        url: "{{ jellyfin_url }}/Users/AuthenticateByName"
        method: POST
        headers:
          Authorization: 'MediaBrowser Client="Ansible", Device="homelab", DeviceId="ansible-config", Version="1.0.0"'
        body_format: json
        body:
          Username: "{{ secrets.jellyfin_admin_user }}"
          Pw: "{{ secrets.jellyfin_admin_password }}"
        status_code: [200, 401]
      register: jellyfin_pre_auth
      no_log: true

    - name: Jellyfin — initial setup
      when: jellyfin_pre_auth.status == 401
      block:
        - name: Jellyfin — set startup configuration
          ansible.builtin.uri:
            url: "{{ jellyfin_url }}/Startup/Configuration"
            method: POST
            body_format: json
            body:
              UICulture: en-US
              MetadataCountryCode: BE
              PreferredMetadataLanguage: en
            status_code: [200, 204]

        - name: Jellyfin — create admin user
          ansible.builtin.uri:
            url: "{{ jellyfin_url }}/Startup/User"
            method: POST
            body_format: json
            body:
              Name: "{{ secrets.jellyfin_admin_user }}"
              Password: "{{ secrets.jellyfin_admin_password }}"
            status_code: [200, 204]
          no_log: true

        - name: Jellyfin — set remote access
          ansible.builtin.uri:
            url: "{{ jellyfin_url }}/Startup/RemoteAccess"
            method: POST
            body_format: json
            body:
              EnableRemoteAccess: true
              EnableAutomaticPortMapping: false
            status_code: [200, 204]

        - name: Jellyfin — complete startup wizard
          ansible.builtin.uri:
            url: "{{ jellyfin_url }}/Startup/Complete"
            method: POST
            status_code: [200, 204]

    - name: Jellyfin — authenticate
      ansible.builtin.uri:
        url: "{{ jellyfin_url }}/Users/AuthenticateByName"
        method: POST
        headers:
          Authorization: 'MediaBrowser Client="Ansible", Device="homelab", DeviceId="ansible-config", Version="1.0.0"'
        body_format: json
        body:
          Username: "{{ secrets.jellyfin_admin_user }}"
          Pw: "{{ secrets.jellyfin_admin_password }}"
      register: jellyfin_auth
      no_log: true

    - name: Jellyfin — get existing libraries
      ansible.builtin.uri:
        url: "{{ jellyfin_url }}/Library/VirtualFolders"
        headers:
          Authorization: 'MediaBrowser Client="Ansible", Device="homelab", DeviceId="ansible-config", Version="1.0.0", Token="{{ jellyfin_auth.json.AccessToken }}"'
      register: jellyfin_libraries

    - name: Jellyfin — add Movies library
      ansible.builtin.uri:
        url: "{{ jellyfin_url }}/Library/VirtualFolders?collectionType=movies&refreshLibrary=false&name=Movies"
        method: POST
        headers:
          Authorization: 'MediaBrowser Client="Ansible", Device="homelab", DeviceId="ansible-config", Version="1.0.0", Token="{{ jellyfin_auth.json.AccessToken }}"'
        body_format: json
        body:
          LibraryOptions: {}
        status_code: [200, 204]
      when: jellyfin_libraries.json | selectattr('Name', 'equalto', 'Movies') | list | length == 0

    - name: Jellyfin — add paths to Movies library
      ansible.builtin.uri:
        url: "{{ jellyfin_url }}/Library/VirtualFolders/Paths"
        method: POST
        headers:
          Authorization: 'MediaBrowser Client="Ansible", Device="homelab", DeviceId="ansible-config", Version="1.0.0", Token="{{ jellyfin_auth.json.AccessToken }}"'
        body_format: json
        body:
          Name: Movies
          PathInfo:
            Path: /media/movies
        status_code: [200, 204]
      when: jellyfin_libraries.json | selectattr('Name', 'equalto', 'Movies') | list | length == 0

    - name: Jellyfin — add TV Shows library
      ansible.builtin.uri:
        url: "{{ jellyfin_url }}/Library/VirtualFolders?collectionType=tvshows&refreshLibrary=false&name=TV%20Shows"
        method: POST
        headers:
          Authorization: 'MediaBrowser Client="Ansible", Device="homelab", DeviceId="ansible-config", Version="1.0.0", Token="{{ jellyfin_auth.json.AccessToken }}"'
        body_format: json
        body:
          LibraryOptions: {}
        status_code: [200, 204]
      when: jellyfin_libraries.json | selectattr('Name', 'equalto', 'TV Shows') | list | length == 0

    - name: Jellyfin — add paths to TV Shows library
      ansible.builtin.uri:
        url: "{{ jellyfin_url }}/Library/VirtualFolders/Paths"
        method: POST
        headers:
          Authorization: 'MediaBrowser Client="Ansible", Device="homelab", DeviceId="ansible-config", Version="1.0.0", Token="{{ jellyfin_auth.json.AccessToken }}"'
        body_format: json
        body:
          Name: TV Shows
          PathInfo:
            Path: /media/tv
        status_code: [200, 204]
      when: jellyfin_libraries.json | selectattr('Name', 'equalto', 'TV Shows') | list | length == 0

    - name: Jellyfin — add Music library
      ansible.builtin.uri:
        url: "{{ jellyfin_url }}/Library/VirtualFolders?collectionType=music&refreshLibrary=false&name=Music"
        method: POST
        headers:
          Authorization: 'MediaBrowser Client="Ansible", Device="homelab", DeviceId="ansible-config", Version="1.0.0", Token="{{ jellyfin_auth.json.AccessToken }}"'
        body_format: json
        body:
          LibraryOptions: {}
        status_code: [200, 204]
      when: jellyfin_libraries.json | selectattr('Name', 'equalto', 'Music') | list | length == 0

    - name: Jellyfin — add paths to Music library
      ansible.builtin.uri:
        url: "{{ jellyfin_url }}/Library/VirtualFolders/Paths"
        method: POST
        headers:
          Authorization: 'MediaBrowser Client="Ansible", Device="homelab", DeviceId="ansible-config", Version="1.0.0", Token="{{ jellyfin_auth.json.AccessToken }}"'
        body_format: json
        body:
          Name: Music
          PathInfo:
            Path: /media/music
        status_code: [200, 204]
      when: jellyfin_libraries.json | selectattr('Name', 'equalto', 'Music') | list | length == 0

    - name: Jellyfin — get encoding settings
      ansible.builtin.uri:
        url: "{{ jellyfin_url }}/System/Configuration/encoding"
        headers:
          Authorization: 'MediaBrowser Client="Ansible", Device="homelab", DeviceId="ansible-config", Version="1.0.0", Token="{{ jellyfin_auth.json.AccessToken }}"'
      register: jellyfin_encoding

    - name: Jellyfin — enable VAAPI hardware transcoding
      ansible.builtin.uri:
        url: "{{ jellyfin_url }}/System/Configuration/encoding"
        method: POST
        headers:
          Authorization: 'MediaBrowser Client="Ansible", Device="homelab", DeviceId="ansible-config", Version="1.0.0", Token="{{ jellyfin_auth.json.AccessToken }}"'
        body_format: json
        body: "{{ jellyfin_encoding.json | combine({'HardwareAccelerationType': 'vaapi', 'VaapiDevice': '/dev/dri/renderD128', 'EnableHardwareEncoding': true, 'EnableTonemapping': true}) }}"
        status_code: [200, 204]
      when: jellyfin_encoding.json.HardwareAccelerationType != 'vaapi'

    # ================================================================
    # JELLYSEERR — initial setup + configuration
    # ================================================================

    - name: Jellyseerr — check if setup is needed
      ansible.builtin.uri:
        url: "{{ jellyseerr_url }}/api/v1/settings/public"
      register: jellyseerr_check

    - name: Jellyseerr — initial setup
      when: not (jellyseerr_check.json.initialized | default(false))
      block:
        - name: Jellyseerr — create admin via Jellyfin auth
          ansible.builtin.uri:
            url: "{{ jellyseerr_url }}/api/v1/auth/jellyfin"
            method: POST
            body_format: json
            body:
              username: "{{ secrets.jellyfin_admin_user }}"
              password: "{{ secrets.jellyfin_admin_password }}"
              hostname: jellyfin
              port: 8096
              useSsl: false
              urlBase: ""
              email: "admin@{{ secrets.domain }}"
              serverType: 2
          register: jellyseerr_admin_create
          no_log: true

        - name: Jellyseerr — read auto-generated API key
          ansible.builtin.uri:
            url: "{{ jellyseerr_url }}/api/v1/settings/main"
            headers:
              Cookie: "{{ jellyseerr_admin_create.cookies_string }}"
          register: jellyseerr_settings

        - name: Jellyseerr — store API key
          ansible.builtin.set_fact:
            jellyseerr_api_key: "{{ jellyseerr_settings.json.apiKey }}"

        - name: Jellyseerr — sync Jellyfin libraries
          ansible.builtin.uri:
            url: "{{ jellyseerr_url }}/api/v1/settings/jellyfin/library?sync=true"
            headers:
              X-Api-Key: "{{ jellyseerr_api_key }}"
          register: jellyseerr_libraries

        - name: Jellyseerr — enable all Jellyfin libraries
          ansible.builtin.uri:
            url: "{{ jellyseerr_url }}/api/v1/settings/jellyfin/library?enable={{ jellyseerr_libraries.json | map(attribute='id') | join(',') }}"
            headers:
              X-Api-Key: "{{ jellyseerr_api_key }}"

        - name: Jellyseerr — initialize
          ansible.builtin.uri:
            url: "{{ jellyseerr_url }}/api/v1/settings/initialize"
            method: POST
            headers:
              X-Api-Key: "{{ jellyseerr_api_key }}"

    - name: Jellyseerr — get API key (existing install)
      ansible.builtin.uri:
        url: "{{ jellyseerr_url }}/api/v1/auth/jellyfin"
        method: POST
        body_format: json
        body:
          username: "{{ secrets.jellyfin_admin_user }}"
          password: "{{ secrets.jellyfin_admin_password }}"
      register: jellyseerr_existing_login
      when: jellyseerr_check.json.initialized | default(false)
      no_log: true

    - name: Jellyseerr — read API key from existing install
      ansible.builtin.uri:
        url: "{{ jellyseerr_url }}/api/v1/settings/main"
        headers:
          Cookie: "{{ jellyseerr_existing_login.cookies_string }}"
      register: jellyseerr_existing_settings
      when: jellyseerr_check.json.initialized | default(false)

    - name: Jellyseerr — store API key (existing install)
      ansible.builtin.set_fact:
        jellyseerr_api_key: "{{ jellyseerr_existing_settings.json.apiKey }}"
      when: jellyseerr_check.json.initialized | default(false)

    - name: Jellyseerr — get existing Sonarr config
      ansible.builtin.uri:
        url: "{{ jellyseerr_url }}/api/v1/settings/sonarr"
        headers:
          X-Api-Key: "{{ jellyseerr_api_key }}"
      register: jellyseerr_sonarr

    - name: Jellyseerr — add Sonarr
      ansible.builtin.uri:
        url: "{{ jellyseerr_url }}/api/v1/settings/sonarr"
        method: POST
        headers:
          X-Api-Key: "{{ jellyseerr_api_key }}"
        body_format: json
        body:
          name: Sonarr
          hostname: sonarr
          port: 8989
          useSsl: false
          apiKey: "{{ secrets.sonarr_api_key }}"
          activeProfileId: 6
          activeProfileName: "HD - 720p/1080p"
          activeDirectory: /media/tv
          is4k: false
          isDefault: true
          enableSeasonFolders: true
        status_code: [200, 201]
      when: jellyseerr_sonarr.json | default([]) | selectattr('name', 'equalto', 'Sonarr') | list | length == 0
      no_log: true

    - name: Jellyseerr — update Sonarr profile to HD 720p/1080p
      ansible.builtin.uri:
        url: "{{ jellyseerr_url }}/api/v1/settings/sonarr/{{ jellyseerr_sonarr_config.id }}"
        method: PUT
        headers:
          X-Api-Key: "{{ jellyseerr_api_key }}"
        body_format: json
        body:
          name: "{{ jellyseerr_sonarr_config.name }}"
          hostname: "{{ jellyseerr_sonarr_config.hostname }}"
          port: "{{ jellyseerr_sonarr_config.port }}"
          useSsl: "{{ jellyseerr_sonarr_config.useSsl }}"
          apiKey: "{{ jellyseerr_sonarr_config.apiKey }}"
          activeProfileId: 6
          activeProfileName: "HD - 720p/1080p"
          activeDirectory: "{{ jellyseerr_sonarr_config.activeDirectory }}"
          is4k: "{{ jellyseerr_sonarr_config.is4k }}"
          isDefault: "{{ jellyseerr_sonarr_config.isDefault }}"
          enableSeasonFolders: "{{ jellyseerr_sonarr_config.enableSeasonFolders | default(true) }}"
        status_code: [200]
      vars:
        jellyseerr_sonarr_config: "{{ jellyseerr_sonarr.json | selectattr('name', 'equalto', 'Sonarr') | first }}"
      when: >-
        jellyseerr_sonarr.json | default([]) | selectattr('name', 'equalto', 'Sonarr') | list | length > 0 and
        (jellyseerr_sonarr.json | selectattr('name', 'equalto', 'Sonarr') | first).activeProfileId != 6
      no_log: true

    - name: Jellyseerr — get existing Radarr config
      ansible.builtin.uri:
        url: "{{ jellyseerr_url }}/api/v1/settings/radarr"
        headers:
          X-Api-Key: "{{ jellyseerr_api_key }}"
      register: jellyseerr_radarr

    - name: Jellyseerr — add Radarr
      ansible.builtin.uri:
        url: "{{ jellyseerr_url }}/api/v1/settings/radarr"
        method: POST
        headers:
          X-Api-Key: "{{ jellyseerr_api_key }}"
        body_format: json
        body:
          name: Radarr
          hostname: radarr
          port: 7878
          useSsl: false
          apiKey: "{{ secrets.radarr_api_key }}"
          activeProfileId: 6
          activeProfileName: "HD - 720p/1080p"
          activeDirectory: /media/movies
          is4k: false
          isDefault: true
          minimumAvailability: released
        status_code: [200, 201]
      when: jellyseerr_radarr.json | default([]) | selectattr('name', 'equalto', 'Radarr') | list | length == 0
      no_log: true

    - name: Jellyseerr — update Radarr profile to HD 720p/1080p
      ansible.builtin.uri:
        url: "{{ jellyseerr_url }}/api/v1/settings/radarr/{{ jellyseerr_radarr_config.id }}"
        method: PUT
        headers:
          X-Api-Key: "{{ jellyseerr_api_key }}"
        body_format: json
        body:
          name: "{{ jellyseerr_radarr_config.name }}"
          hostname: "{{ jellyseerr_radarr_config.hostname }}"
          port: "{{ jellyseerr_radarr_config.port }}"
          useSsl: "{{ jellyseerr_radarr_config.useSsl }}"
          apiKey: "{{ jellyseerr_radarr_config.apiKey }}"
          activeProfileId: 6
          activeProfileName: "HD - 720p/1080p"
          activeDirectory: "{{ jellyseerr_radarr_config.activeDirectory }}"
          is4k: "{{ jellyseerr_radarr_config.is4k }}"
          isDefault: "{{ jellyseerr_radarr_config.isDefault }}"
          minimumAvailability: "{{ jellyseerr_radarr_config.minimumAvailability | default('released') }}"
        status_code: [200]
      vars:
        jellyseerr_radarr_config: "{{ jellyseerr_radarr.json | selectattr('name', 'equalto', 'Radarr') | first }}"
      when: >-
        jellyseerr_radarr.json | default([]) | selectattr('name', 'equalto', 'Radarr') | list | length > 0 and
        (jellyseerr_radarr.json | selectattr('name', 'equalto', 'Radarr') | first).activeProfileId != 6
      no_log: true

    # ================================================================
    # BAZARR — connect to Sonarr + Radarr, enable subtitles
    # ================================================================

    - name: Bazarr — read API key from config
      ansible.builtin.slurp:
        src: /mnt/data/docker/bazarr/config/config/config.yaml
      register: bazarr_config_raw

    - name: Bazarr — parse API key
      ansible.builtin.set_fact:
        bazarr_api_key: "{{ (bazarr_config_raw.content | b64decode | from_yaml).auth.apikey }}"

    - name: Bazarr — wait for API
      ansible.builtin.uri:
        url: "{{ bazarr_url }}/api/system/status"
        headers:
          X-API-KEY: "{{ bazarr_api_key }}"
        status_code: [200]
      register: bazarr_status
      retries: 6
      delay: 10
      until: bazarr_status is not failed

    - name: Bazarr — get current settings
      ansible.builtin.uri:
        url: "{{ bazarr_url }}/api/system/settings"
        headers:
          X-API-KEY: "{{ bazarr_api_key }}"
      register: bazarr_settings

    - name: Bazarr — configure Sonarr connection
      ansible.builtin.uri:
        url: "{{ bazarr_url }}/api/system/settings"
        method: POST
        headers:
          X-API-KEY: "{{ bazarr_api_key }}"
        body_format: json
        body:
          settings:
            general:
              use_sonarr: true
            sonarr:
              ip: sonarr
              port: 8989
              base_url: /
              apikey: "{{ secrets.sonarr_api_key }}"
              ssl: false
              only_monitored: false
              series_sync: 60
        status_code: [200, 202, 204]
      when: >-
        bazarr_settings.json.settings.sonarr.apikey | default('') != secrets.sonarr_api_key
      no_log: true

    - name: Bazarr — configure Radarr connection
      ansible.builtin.uri:
        url: "{{ bazarr_url }}/api/system/settings"
        method: POST
        headers:
          X-API-KEY: "{{ bazarr_api_key }}"
        body_format: json
        body:
          settings:
            general:
              use_radarr: true
            radarr:
              ip: radarr
              port: 7878
              base_url: /
              apikey: "{{ secrets.radarr_api_key }}"
              ssl: false
              only_monitored: false
              movies_sync: 60
        status_code: [200, 202, 204]
      when: >-
        bazarr_settings.json.settings.radarr.apikey | default('') != secrets.radarr_api_key
      no_log: true

    # ================================================================
    # AUTOBRR — create account, add download client
    # ================================================================

    - name: Autobrr — check if account exists
      ansible.builtin.uri:
        url: "{{ autobrr_url }}/api/auth/login"
        method: POST
        body_format: json
        body:
          username: "{{ secrets.jellyseerr_admin_user }}"
          password: "{{ secrets.jellyseerr_admin_password }}"
        status_code: [200, 204, 401, 403, 422]
      register: autobrr_login_check
      ignore_errors: true

    - name: Autobrr — create initial account
      ansible.builtin.uri:
        url: "{{ autobrr_url }}/api/auth/onboard"
        method: POST
        body_format: json
        body:
          username: "{{ secrets.jellyseerr_admin_user }}"
          password: "{{ secrets.jellyseerr_admin_password }}"
        status_code: [200, 201, 204, 422]
      when: autobrr_login_check.status in [401, 403]
      no_log: true

    - name: Autobrr — login
      ansible.builtin.uri:
        url: "{{ autobrr_url }}/api/auth/login"
        method: POST
        body_format: json
        body:
          username: "{{ secrets.jellyseerr_admin_user }}"
          password: "{{ secrets.jellyseerr_admin_password }}"
        status_code: [200, 204]
      register: autobrr_login
      no_log: true

    - name: Autobrr — get existing download clients
      ansible.builtin.uri:
        url: "{{ autobrr_url }}/api/download_clients"
        headers:
          Cookie: "{{ autobrr_login.cookies_string }}"
      register: autobrr_clients

    - name: Autobrr — add qBittorrent download client
      ansible.builtin.uri:
        url: "{{ autobrr_url }}/api/download_clients"
        method: POST
        headers:
          Cookie: "{{ autobrr_login.cookies_string }}"
        body_format: json
        body:
          name: Seedbox
          type: QBITTORRENT
          enabled: true
          host: "http://{{ seedbox_qbit_host }}:{{ seedbox_qbit_port }}"
          settings:
            basic:
              auth: true
              username: "{{ seedbox_qbit_user }}"
              password: "{{ seedbox_qbit_password }}"
            rules: {}
        status_code: [200, 201]
      when: autobrr_clients.json | default([]) | selectattr('name', 'equalto', 'Seedbox') | list | length == 0
      no_log: true

    # ================================================================
    # Summary
    # ================================================================

    - name: Configuration complete
      ansible.builtin.debug:
        msg:
          - "Configuration complete!"
          - "Sonarr: root folder /media/tv, download client configured, remote path mapping set"
          - "Radarr: root folder /media/movies, download client configured, remote path mapping set"
          - "Prowlarr: connected to Sonarr, Radarr, Lidarr"
          - "Lidarr: root folder /media/music, download client configured, remote path mapping set"
          - "Jellyfin: setup wizard completed, libraries added, VAAPI transcoding enabled"
          - "Jellyseerr: connected to Jellyfin, Sonarr, Radarr"
          - "Bazarr: connected to Sonarr + Radarr, English subtitles enabled"
          - "Autobrr: account created, qBittorrent download client added"
          - ""
          - "Next: run 05d-trackers.yml for Prowlarr indexers + Autobrr IRC"
          - ""
          - "Manual steps remaining:"
          - "  - Bazarr: add subtitle providers (OpenSubtitles, Addic7ed, etc.)"
          - "  - Jellyfin: fine-tune transcoding settings if needed"
